use super::{Secrets, Topology, VolumeCapability, VolumeContentSource};
use crate::proto;
use std::{
  collections::HashMap,
  convert::{TryFrom, TryInto},
  num::NonZeroU64,
};
use thiserror::Error;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CapacityRange {
  AtLeast(NonZeroU64),
  AtMost(NonZeroU64),
  /// Effectively AtLeast(.0) & AtMost(.1)
  Between(NonZeroU64, NonZeroU64),
}

impl TryFrom<proto::CapacityRange> for CapacityRange {
  type Error = tonic::Status;

  fn try_from(value: proto::CapacityRange) -> Result<Self, Self::Error> {
    match (value.required_bytes, value.limit_bytes) {
      (r, _) if r < 0 => Err(tonic::Status::invalid_argument(
        "CapacityRange.required_bytes cannot be negative",
      )),
      (_, l) if l < 0 => Err(tonic::Status::invalid_argument(
        "CapacityRange.limit_bytes cannot be negative",
      )),
      (r, 0) => Ok(CapacityRange::AtLeast(NonZeroU64::new(r as u64).unwrap())),
      (0, l) => Ok(CapacityRange::AtMost(NonZeroU64::new(l as u64).unwrap())),
      (r, l) => Ok(CapacityRange::Between(
        NonZeroU64::new(r as u64).unwrap(),
        NonZeroU64::new(l as u64).unwrap(),
      )),
    }
  }
}

#[derive(Debug)]
pub enum TopologyRequirement {
  Requisite(Vec<Topology>),
  Preferred(Vec<Topology>),
  RequisiteAndPreffered {
    requisite: Vec<Topology>,
    preferred: Vec<Topology>,
  },
}

impl TryFrom<proto::TopologyRequirement> for TopologyRequirement {
  type Error = tonic::Status;

  fn try_from(value: proto::TopologyRequirement) -> Result<Self, Self::Error> {
    fn topology(
      v: Vec<proto::Topology>,
      name: &'static str,
    ) -> Result<Vec<Topology>, tonic::Status> {
      v.into_iter()
        .enumerate()
        .map(|(i, t)| {
          if t.segments.is_empty() {
            Err(tonic::Status::invalid_argument(format!(
              "Topology.{}[{}] has 0 segments",
              name, i
            )))
          } else {
            Ok(t.segments)
          }
        })
        .collect::<Result<_, _>>()
    }

    match (value.requisite, value.preferred) {
      (r, p) if r.is_empty() && p.is_empty() => Err(tonic::Status::invalid_argument(
        "TopologyRequirement had neither requisite nore preferred",
      )),
      (r, p) if r.is_empty() => Ok(TopologyRequirement::Preferred(topology(p, "preferred")?)),
      (r, p) if p.is_empty() => Ok(TopologyRequirement::Requisite(topology(r, "requisite")?)),
      (r, p) => Ok(TopologyRequirement::RequisiteAndPreffered {
        requisite: topology(r, "requisite")?,
        preferred: topology(p, "preferred")?,
      }),
    }
  }
}

#[derive(Debug)]
pub struct CreateVolumeRequest {
  name: String,
  capacity_range: Option<CapacityRange>,
  volume_capabilities: Vec<VolumeCapability>,
  parameters: HashMap<String, String>,
  secrets: Secrets,
  volume_content_source: Option<VolumeContentSource>,
  accessibility_requirements: Option<TopologyRequirement>,
}

impl CreateVolumeRequest {
  /// The suggested name for the storage space. This field is REQUIRED.
  /// It serves two purposes:
  ///
  /// 1) Idempotency - This name is generated by the CO to achieve
  ///    idempotency.  The Plugin SHOULD ensure that multiple
  ///    `CreateVolume` calls for the same name do not result in more
  ///    than one piece of storage provisioned corresponding to that
  ///    name. If a Plugin is unable to enforce idempotency, the CO's
  ///    error recovery logic could result in multiple (unused) volumes
  ///    being provisioned.
  ///    In the case of error, the CO MUST handle the gRPC error codes
  ///    per the recovery behavior defined in the "CreateVolume Errors"
  ///    section below.
  ///    The CO is responsible for cleaning up volumes it provisioned
  ///    that it no longer needs. If the CO is uncertain whether a volume
  ///    was provisioned or not when a `CreateVolume` call fails, the CO
  ///    MAY call `CreateVolume` again, with the same name, to ensure the
  ///    volume exists and to retrieve the volume's `volume_id` (unless
  ///    otherwise prohibited by "CreateVolume Errors").
  /// 2) Suggested name - Some storage systems allow callers to specify
  ///    an identifier by which to refer to the newly provisioned
  ///    storage. If a storage system supports this, it can optionally
  ///    use this name as the identifier for the new volume.
  ///
  /// Any Unicode string that conforms to the length limit is allowed
  /// except those containing the following banned characters:
  /// U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
  /// (These are control characters other than commonly used whitespace.)
  #[inline]
  pub fn name(&self) -> &str {
    &self.name
  }

  /// This field is OPTIONAL. This allows the CO to specify the capacity
  /// requirement of the volume to be provisioned. If not specified, the
  /// Plugin MAY choose an implementation-defined capacity range. If
  /// specified it MUST always be honored, even when creating volumes
  /// from a source; which MAY force some backends to internally extend
  /// the volume after creating it.
  #[inline]
  pub fn capacity_range(&self) -> Option<&CapacityRange> {
    self.capacity_range.as_ref()
  }

  /// The capabilities that the provisioned volume MUST have. SP MUST
  /// provision a volume that will satisfy ALL of the capabilities
  /// specified in this list. Otherwise SP MUST return the appropriate
  /// gRPC error code.
  /// The Plugin MUST assume that the CO MAY use the provisioned volume
  /// with ANY of the capabilities specified in this list.
  /// For example, a CO MAY specify two volume capabilities: one with
  /// access mode SINGLE_NODE_WRITER and another with access mode
  /// MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
  /// provisioned volume can be used in either mode.
  /// This also enables the CO to do early validation: If ANY of the
  /// specified volume capabilities are not supported by the SP, the call
  /// MUST return the appropriate gRPC error code.
  /// This field is REQUIRED.
  #[inline]
  pub fn volume_capabilities(&self) -> impl Iterator<Item = &VolumeCapability> + ExactSizeIterator {
    self.volume_capabilities.iter()
  }

  /// Plugin specific parameters passed in as opaque key-value pairs.
  /// This field is OPTIONAL. The Plugin is responsible for parsing and
  /// validating these parameters. COs will treat these as opaque.
  #[inline]
  pub fn parameters(&self) -> &HashMap<String, String> {
    &self.parameters
  }

  /// Secrets required by plugin to complete volume creation request.
  /// This field is OPTIONAL. Refer to the `Secrets Requirements`
  /// section on how to use this field.
  #[inline]
  pub fn secrets(&self) -> &HashMap<String, String> {
    self.secrets.as_ref()
  }

  /// If specified, the new volume will be pre-populated with data from
  /// this source. This field is OPTIONAL.
  #[inline]
  pub fn volume_content_source(&self) -> Option<&VolumeContentSource> {
    self.volume_content_source.as_ref()
  }

  /// Specifies where (regions, zones, racks, etc.) the provisioned
  /// volume MUST be accessible from.
  /// An SP SHALL advertise the requirements for topological
  /// accessibility information in documentation. COs SHALL only specify
  /// topological accessibility information supported by the SP.
  /// This field is OPTIONAL.
  /// This field SHALL NOT be specified unless the SP has the
  /// VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
  /// If this field is not specified and the SP has the
  /// VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
  /// choose where the provisioned volume is accessible from.
  #[inline]
  pub fn accessibility_requirements(&self) -> Option<&TopologyRequirement> {
    self.accessibility_requirements.as_ref()
  }
}

impl TryFrom<proto::CreateVolumeRequest> for CreateVolumeRequest {
  type Error = tonic::Status;

  fn try_from(value: proto::CreateVolumeRequest) -> Result<Self, Self::Error> {
    if value.name.is_empty() {
      return Err(tonic::Status::invalid_argument(
        "CreateVolume Name must be provided",
      ));
    }

    if value.volume_capabilities.is_empty() {
      return Err(tonic::Status::invalid_argument(
        "CreateVolume Volume capabilities must be provided",
      ));
    }

    let name = value.name;
    let capacity_range = value.capacity_range.map(TryInto::try_into).transpose()?;
    let volume_capabilities = value
      .volume_capabilities
      .into_iter()
      .map(TryInto::try_into)
      .collect::<Result<_, _>>()?;
    let parameters = value.parameters;
    let secrets = value.secrets.into();
    let volume_content_source = match value.volume_content_source {
      None => None,
      Some(v) => v.try_into()?,
    };
    let accessibility_requirements = value
      .accessibility_requirements
      .map(TryInto::try_into)
      .transpose()?;

    Ok(CreateVolumeRequest {
      name,
      capacity_range,
      volume_capabilities,
      parameters,
      secrets,
      volume_content_source,
      accessibility_requirements,
    })
  }
}

#[non_exhaustive]
#[derive(Debug, Error)]
pub enum CreateVolumeError {
  /// Besides the general cases, this code MUST also be used to indicate when plugin
  /// supporting CREATE_DELETE_VOLUME cannot create a volume from the requested source
  /// (`SnapshotSource` or `VolumeSource`). Failure MAY be caused by not supporting
  /// the source (CO SHOULD NOT have provided that source) or incompatibility between
  /// `parameters` from the source and the ones requested for the new volume. More
  /// human-readable information SHOULD be provided in the gRPC `status.message` field
  /// if the problem is the source.
  #[error("Source incompatible or not supported: {0}")]
  SourceIncompatible(String),

  /// Indicates that the specified source does not exist.
  #[error("Source does not exist: {0}")]
  SourceNotFound(String),

  /// Indicates that a volume corresponding to the specified volume `name` already exists
  /// but is incompatible with the specified `capacity_range`, `volume_capabilities`,
  /// `parameters`, `accessibility_requirements` or `volume_content_source`.
  #[error("Volume already exists but is incompatible: {0}")]
  AlreadyExists(String),

  /// Indicates that although the `accessible_topology` field is valid, a new volume can
  /// not be provisioned with the specified topology constraints. More human-readable
  /// information MAY be provided in the gRPC `status.message` field.
  #[error("Unable to provision in 'accessible_topology': {0}")]
  UnableToProvision(String),

  /// Indicates that the capacity range is not allowed by the Plugin, for example when
  /// trying to create a volume smaller than the source snapshot. More human-readable
  /// information MAY be provided in the gRPC `status.message` field.
  #[error("Unsupported 'capacity_range': {0}")]
  UnsupportedCapacityRange(String),

  #[error(transparent)]
  #[doc(hidden)]
  Other(#[from] tonic::Status),
}

impl From<CreateVolumeError> for tonic::Status {
  fn from(value: CreateVolumeError) -> tonic::Status {
    use tonic::{Code, Status};

    match value {
      CreateVolumeError::SourceIncompatible(v) => Status::new(Code::InvalidArgument, v),
      CreateVolumeError::SourceNotFound(v) => Status::new(Code::NotFound, v),
      CreateVolumeError::AlreadyExists(v) => Status::new(Code::AlreadyExists, v),
      CreateVolumeError::UnableToProvision(v) => Status::new(Code::ResourceExhausted, v),
      CreateVolumeError::UnsupportedCapacityRange(v) => Status::new(Code::OutOfRange, v),
      CreateVolumeError::Other(v) => v,
    }
  }
}
